进程是系统资源分配的基本单位
线程是任务分配的基本单位

1.java中的多线程实现方式
继承Thread类
实现Runnable、Callable
线程池(推荐)

2.多线程的常用操作方法
sleep();线程休眠,把线程从运行态变到阻塞态-->不会释放锁,立即交出cpu-->根据设置的时间恢复
yield();线程让步,直接将线程从运行态变到就绪态->同样不会释放锁,交出cpu时间不确定,由系统调度
只会让拥有相同时间优先级的线程有获取cpu的机会;

join():当前线程等待另一个线程执行完毕后,谁调等待谁结束,-->进入阻塞态,会释放锁
wait()/notify():synchronized                        -->运行态到阻塞态;
                                                    -->从阻塞态到运行态,两个方法都会释放线程锁
要使用wait/notify,必须在同步方法或同步代码块中使用

Object类的每个对象在jvm中都用一个监视器,有两个队列
同步队列:获取该对象锁失败的线程进入

等待队列:被wait的进入等待,直到notify

创建->就绪->运行->结束
        |   |
        |阻塞

用户线程:包括main方法的线程,属于用户定义程序结束就结束
守护线程:后台线程,只有当JVM最后一个线程终止才会终止
setDeamn可以将用户线程置为守护线程,只要将它置为true

3.同步和死锁
    保护的对象是谁 锁是谁

JVM内存模型(JMM):并发模型
描述共享变量(类成员变量,静态变量)如何存储

工作内存:变量在线程中的操作(读写)必需在工作内存中进行,这里面即需要保存着所有变量的副本
主内存:所有变量必需在这里存储

原子性:一组操作要么同时发生,要么一个都不发生
基本数据类型的读写操作都属于原子性操作

可见性:某一线程对于变量的修改对于其他线程而言是立即可见的
synchronize,volatile,final能保证可见性

有序性:在单线程场景下,所有代码执行顺序就是代码的书写顺序,多线程场景下所有代码都是乱序

只有以上三个特性同时满足的代码才是线程安全的

如何解决同步?
同步代码块
synchronized(对象----任一类的对象或类的class对象)
同步方法
修饰类成员方法,锁当前对象this
修饰类方法(static)锁的是当前类的反射对象(类.class)