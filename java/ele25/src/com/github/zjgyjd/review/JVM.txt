1.JVM运行时区域划分
线程私有:
        程序计数器(记录当前执行到的行数)
        虚拟机栈(描述方法内存模型)
        本地方法栈(记录native方法)
        HotspotJVM中本地方法栈与虚拟机栈合二为一

线程共享:
        堆:所有对象实例以及数组对象
        方法区:已加载的类信息 , 静态变量 , 常量
        运行时常量池:方法去的一部分 , 字面量与符号引用

        字面量:直接写出来的值 如:10 "abc"
        符号引用: 不同包的不同类有不同的引用符号

2.GC相关
如何判断对象是否存活 -> 对象的自我拯救 finalize -> 垃圾回收算法
如何判断对象存活
引用计数法:无法解决循环引用问题(我中有你,你中有我)
Person per1 = new Person();//此时计数器为1
Person per2 = new Person();//此时计数器为1
per1.obj = per2;//此时计数器加到2
per2.obj = per1;//此时计数器加到2
per2 = per1 = null;//此时计数器减了一次
这个情况就会导致内存泄漏,还有本来外部已经变成了null但计数器次数无法消毁对象

2.可达性算法:
那些对象可以作为GC Root?
1.栈中引用的对象
2.类中的静态变量,常量

***** JDK1.2之后关于引用的扩充 *****
强引用:程序中中普遍存在的,类似于直接new的,只要对象被任意一个强引用指向,抛出了OOM(out of memory)也无法回收对象
软引用:描述有用但不必须对象,SoftReference类描述软引用,若对象只被软引用指向,当前内存够用不回收,否则抛OOM后直接回收
弱:WeakReference
仅被弱引用指向的对象,无论内存是否够用,当GC开始时,都会回收只被弱引用指向的对象
虚:PhantomReference
虚引用完全不对对象的生存周期产生任何影响,也无法通过虚引用取得对象实例。
当虚引用指向的对象被GC时,JVM会发回一个回收通知

对象的自我拯救 finalize
    若对象所在的类覆写了finalize()
        该对象的finalize()未被JVM调用,JVM会调用此对象的finalize()
        该对象的finalize()被JVM调用过,此时对象会被标记不在存活,被GC
    没覆写finalize(),此时直接被标记为不在存活,被GC

垃圾回收算法
将堆空间分为新生代和老年代,对象默认在新时代产生,新时代对象"朝生父死",新生代存活率低(<= 2%)
Java采用分代回收算法,新生代采用复制算法,老年代采用标记-整理算法
-Xss(设置栈的大小)128k
-Xms(设置堆的最小值)10m
-Xmx(设置堆的最大值)
-Xmn(设置新生代的大小)

复制算法:
step1:当Eden区第一次快满时,将Eden区所有存活对象复制到From,然后依次清空Eden
step2:当Eden区第二次快满时,将Eden区与From区的存活对象复制到To区,依次清理掉Eden和From区
step3:循环(第三次满,将Eden和To,在全移动到From区)....

若干对象在From和To来回复制15次以上,将该对象移动到老年代

|__________Eden________|
|_Survivor_From_|  |_Survivor_To_|
新生代复制算法比老年代算法效率高,且发生频率高,为什么老年代不采用?
因为老年代的存活率高,复制开销运高于新生代不适合复制算法

标记-整理:将所有存活对象标记,向一端整理

3.JDK的内置工具的使用
Jps : 看id
Jmap :看堆
Jstack : 看栈

4.JMM
volatile(选看)
    -可见性
    -禁止指令重排(Double-Check-Singleton)双重加锁单例模式

    禁止指令重排
    被volatile修饰的代码即不会提前也不会滞后
    在这一行之前的代码一定全部执行完成,在这之后的代码一定没有执行