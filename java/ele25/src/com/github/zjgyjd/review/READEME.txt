1.LinkedList ArrayList Vector关系与区别
2.请问了解jcl fail-fast策略?fail-safe呢?
3.Set接口与Map接口的关系
4.hashCode与equals的关系(下面有)


-------------------------------------------

SE:
多线程
类集
JVM
final finally finalize 区别

java 的方法都是---------值传递-----------  //需要详细研究

------------字符串--------------
//程序从右往左执行   abc进常量池  然后 new一个 对象  最后有两个
String str = new String ("abc");

字符串 用+ 拼接 就会变成StringBuilder  也就是其.append操作  最后变成String  用的是 toString方法
该方法  return了个  new String
纯常量的字符串拼接   和 之前相比的字符串相等

字符串拼接时  只有纯常量拼接  不会转为 StringBuilder
直接在常量池  中寻找  是否存在已有值
否则 只要 存在 一个 字符串 变量的 "+"  都会转为StringBuilder  调用append方法

----------异常------------

异常体系中  若finally 代码块中 存在 return  语句  则 try  catch  中的 return 失效
若  finally  中 无return         try  catch 中有  则  try  catch  代码块中 先暂存  代码块中的值
然后执行  finally  中的  值  最后返回 暂存值。

---------多线程-------------

三种方法 创建 多线程  Thread  Runnable  Callable(有返回值)

各种 锁  要理解

---------------集合类----------------

迭代遍历 一个集合的方式

-----------数据结构-----------
如何在o(n)的复杂度内  查找 100w个元素中的  第十大元素     //top key问题：快速排序  分区思想

如何在小于o(nlogn)时间内  找到 100w个元素中的前十个元素   ：优先级队列  一个堆

非递归中序遍历二叉树    ：   深度优先遍历：前中后序遍历   广度优先遍历：用栈的思想  层序遍历

数据结构的各个oj题 再做做  各个排序方法

------------数据库------------

_%

事务的ACID特性

多表查询

------------网络--------------

Tcp/ip

三次握手  四次挥手

HTTP  401  500服务器错误 301重定向

------------类集---------------

1.LinkedList ArrayList Vector 的关系与区别
    a.都是 List接口下的常用子类，其中ArrayList，Vector是基于数组实现的
        LinkedList 基于双向链表实现。

    b.ArrayList采用慢加载策略，第一次添加元素时才初始化内部数组(大小为10)。
        扩容：ArrayList 扩容为原先数组的1.5倍。
        采用异步处理，线程不安全，性能较高。
        ArrayList使用场景： 在大部分场合 一般考虑使用 ArrayList

    c.Vector 在产生对象时初始化为一个大小为10的内部数组。(无参构造)
        扩容：Vector扩容为原先数组的2倍。
        Vector 采用synchronized 修饰常用的增删改查方法，线程安全，性能较低(读读互斥)。
        ***Java 提供的 栈实现 Stack 是 Vector的子类。***所以性能叫低,读读互斥,需要自己写一个性能较高的栈

    d.LinkedList 在  任意位置  的插入和删除 需要考虑 LinkedList,Queue 接口的子类实现。
        //如何用双栈模拟队列  如何用双队列模拟栈。

2.请问了解JCL 的 fail-fast 策略吗fail-safe 又是什么？

    什么是fail-fast?
        优先考虑出现异常的场景，当异常产生时，直接抛出异常，程序终止。

    为何会产生 fail-fast?
        源码if(modCount != expectedModCount) throw new ConcurrentModificationException
        modCount  (存在于abstractList) 记录 List集合 被 修改(add,remove)的次数
        expectedModCount存在于内部迭代器实现，用来存储当前集合的修改次数。

    fail-fast 的 意义？
        保证多线程场景下  不产生 “脏读”。  您拿到的数据已经不是最新的了。


    fail-safe是啥？
        不抛出ConcurrentModificationException 的集合就是 fail-safe 集合
        juc包下线程安全的集合类(copyOnWriteArrayList,ConcurrentHashMap) 都不抛这个异常。

3.Set接口 和 Map接口 的区别？关系？

     Set实际上内部就是Map  保存单个元素存储在Map
     Set是不允许数据重复的,其中HashSet判断两个对象是否重复的依据是equals和hashCode
     TreeSet元素想保存,要么本身实现内部排序,要么传入一个比较器


4.hashCode 与 equals的关系
hashCode的返回值相同的对象,equals是否相等?
此时不一定相等,为x(equals)和f(x)(hashCode)的关系
equals返回相等时,hashCode是否相等
此时一定相等,即x相等,问f(x)是否相同



5.java 实现大小比较的方式 （内部排序，外部排序）两个对象间
内部排序(自己与别人) Comparable
实现了Comparable接口的子类,表示本类具备天然的可比较特性
int compareTo(Object o)
>0 本身大于目标对象
=0 本身等于目标对象
<0 本身小于目标对象

外部排序:Comparator
类本身不具备可比较特性,所以使用专门有一个类来比较这些类的大小,这就是比较器
是一种策略模式

TreeSet使用这两个排序进行排序
当一个类本身可以比较,此时在外部却传了一个不一样的比较器时,会按传入的比较器进行排序,
因为TreeSet在构造函数中传入比较器就会使用比较器
6.HashMap TreeMap 与 HashTable 的 关系 与 区别？
a.这三个都是Map接口下的常用子类,其中Hashtable基于哈希表实现,TreeMap基于红黑树实现,
HashMap基于红黑树和哈希表实现,在1.8之后
哈希表:(K,V)
根据相应的算法计算key,返回V中存储的Value值
其中算法根据传入的K算出V需要存储的数组的下标(int型),此时查找,添加元素都为O(1);
哈希冲突:即hash算法计算时,两个不同对象计算的值相等,此时就需要解决hash冲突
解决方案:
    开放定址法:
    寻找下一个为null的数组下标,而后将冲突元素储存
    再散列法:
    再次使用一个不同的hash算法在计算一次,得到全新的数组下标
    链地址法(拉链法)
    将所有冲突元素按照链表存储,HashMap就运用了这种方法
当出现冲突时查找和添加的时间复杂度就变成了O(1+n)

b.关于null值,
HashMap允许key和value为null
HashTable两个都不能为空
TreeMap允许Value可以为空

c.线程安全性
HashMap,TreeMap都是异步处理,线程不安全性能较高
HashTable 加上了方法锁,锁住了整个对象,线程安全但性能较低,读读都会产生互斥

7.HashMap 源码 解析  （负载因子  树化策略  内部 hash 策略  resize策略）
内部属性:
LoadFactory(负载因子:帮助设定实际容量,当过大时hash冲突会增加,但可节约内存;过小时导致hash表频繁扩容内存利用率低)  实际容量(int threshold = 负载因子 * n[长度]) TREEIFY_THRESHOLD = 8(树化阈值) UNTREEIFY_THRESHOLD = 6(解除树化阈值)
构造函数: 无参时将负载因子赋值,为默认值0.75 此时说明采用了懒加载策略,在第一次put时才初始化哈希表
put方法:
        put()->hash()----------------------------------------------------------------------------------------------------------------------->putVal(hash,K,V)
                |->HashMap内部hash算法->为什么不直接用提供的hashCode()?                                                                         |
                                            |-->因为原hash值太大过于浪费空间,所以右移16位即去除一半,然后将全部的hash值异或一半的值,打散hash冲突    |                                                          |-->扩容为原来数组的二倍
                                                                                                                                              |---> 1.先判断哈希表是不是空,是空则初始化哈希,     其中有个resize()可以进行哈希表初始化和扩容
                                                                                                                                              |---> 2.当目标索引的下标内未存储元素时,将当前元素存储进去
                                                                                                                                              |              |-->下标计算(i = hash&(n-1))n为哈希表的长度,必须为2的n次方,可以保证hash表中的所有下标都能访问到,也同时保证了算出的下标一定在hash的范围内
                                                                                                                                              |                                 |-->虽然变小了但还是很大不能直接用来当数组下标
                                                                                                                                              |---> 3.此时下标索引重复,有几个情况
                                                                                                                                                            |----->索引下标对应的元素K值,恰好与当前元素相等且不为null,就会发生替换将当前value值替换进去
                                                                                                                                                            |----->如果已经发生了树化,就用红黑树的方式进行添加
                                                                                                                                                            |----->以链表方式进行添加
                                                                                                                                                                       |---->先遍历找到链表的末尾,添加元素,进行判断添加完后是否到达链表阈值8,达到则尝试树化
                                                                                                                                                                       |                                                                          |--->但此时还要判断Hash表的长度有没有到达64,到达此时才会树化,否则只是会调用resize()扩容
                                                                                                                                                                       |--->发现有K值一样则同样替换Value
                                                                                                                                                                                                                                                                                                        |--->只树化达到阈值的

                                                                                                                                              |此时添加节点时,要让size++,并与实际容量进行判断,大于则扩容

        为什么要树化?当hash冲突严重时,用链的话会使查找程度变成O(n)而树化可以使查找速率为O(log(n))
        但当红黑树节点小于6时就会发生树退化,变成链表
8.ConcurrentHashMap  如何高效实现 线程安全？
HashTable锁的是整个哈希表,效率会非常低,因为只有一个锁,造成读读互斥
9.ConcurrentHashMap JDK 1.7 与 1.8 的区别？
1.7版本的时候,它的结构是Segment加Hash表,注意Segment不会扩容,扩容会将Segment对应的Hash表进行扩容
1.7版本的时候,会将Segment进行加锁,即加了16把锁,提高了效率
Segment是ReentrantLock的子类,使用Lock保证线程安全

1.8版本的时候,结构变成了Hash表加红黑树,Segment不在作用,直接锁hash桶里面的小元素头,锁的个数可以跟随扩容而扩容
此时使用cas下的synchronized保证了线程的安全性
        |-->咨询