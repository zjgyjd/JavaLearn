搜索专题:
    1.知道搜索的应用场景,做几道常见的OJ题
    2.学习搜索的数据结构
        1.搜索树
            1.红黑树
            2.AVL树
            3.B树 和 B+树
        2.哈希表
        3.二分查找
        对比这几种数据结构的优劣性及适用场景
    3.Java中搜索相关的集合类
        Map(TreeMap|HashMap)
        Set(TreeSet|HashSet)


    1.生活中的搜索
        1.根据一个条件,找到一组结果
        2.确定一个集合中有没有一个具体的数
        3.统计出现次数

    1.搜索树
    任意节点的左子树的值都小于节点的值
              右子树的值都大于节点的值
    小在左,大在右       时间复杂度就是二叉树的高度  从O(log(n))----O(n)

    2.平衡树   就是为了解决搜索树的高度不确定问题
    1.AVL树
        要求树中每一个节点的左子树的高度和右子树的高度差的绝对值不能超过一
        难度:   随着插入的进行,树可能不平衡                (此处有问题)
                当遇上不平衡时,就进行旋转变平衡
                左旋:往右插,刚好右子树右边比左边高
                右旋:往左插,刚好左子树左边比右边低
                先对根左子树左旋在对根做右旋:往左插,左子树右边比左边高
                先对根右子树右旋在对根做左旋:往右插,右子树左边比右边低
        2.旋转是常数,不影响时间复杂度 O(log(n));

    2.更新平衡因子,如果保存可以节约空间,如果直接保存高度则空间浪费

    3.红黑树
        1.每个结点有颜色,或红,或黑              0|1
        2.红色不和红色相邻
        3.根节点一定是黑色的
        4.叶子结点(null)黑色的
        5.从根到每一个叶子,所有这样的路径上,黑色数量是一样多的(最长一条路不会超过最短的两倍)
        当插入红色时,如果父亲是红色的则需要调整:
            1.因为根不可能是红的,所以父亲必然存在父亲且颜色肯定为黑
        三种情况:
            1.有叔叔节点且当叔叔是红的时,则改变祖父黑色变红,将父亲和叔叔全变黑
            2.没有叔叔或叔叔是黑的,当没叔叔时,对父亲做右旋然后再将父亲变成黑的,在将祖父变红
            3.当有叔叔时由于黑色数量相同,说明是递归来到的,红色本身带有子树,同样右旋,将祖父变红
            3.当往父亲右边插入时,先让父亲左旋,然后改颜色再让祖父右旋(? ? ?)

    4.B树/B+树/B*树
    数据库的索引(index)的目的?
        提升查找效率                                                            root
        1.搜索树(B+数  多叉树)         默认     根上记录了每一个枝丫的分界线,   /  |  \
                                                                        [0,a] (a,b] [b,无穷);
              1.因为磁盘读写效率低,B树系列因为多孩子,高度低,读写次数少,所以此时B树更合适,平衡二叉树不太行
              2.B树 值除了在叶子中,中间节点也保存
                B+树 值全部在叶子中
        Java中应用搜索树的有两个类 TreeMap<K,V> TreeSet<K>  都是红黑树
        2.哈希
        对数据进行分类存储,用数组来说:每一个下标存一个某种hash()函数算出下标的数
        此时就会有重复下标产生(哈希冲突)
        解决:
            1.开放地址法(闭散列)
                遇到冲突,重新计算下标
                    1.线性探测法:挨个找
                    2.二次探测:可是空间拉开一点
            2.哈希桶(数组中存的是链表)
