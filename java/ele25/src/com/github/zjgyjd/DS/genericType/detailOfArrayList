   /*< p >可调整数组实现的列表接口。实现了所有可选列表操作，并允许所有元素，包括null。除了实现List接口外，
     这个类提供了操作数组大小的方法内部用于存储列表。(这个类大致相当于向量，但它是不同步的
   */

   /*< p >size、isEmpty、get、set、iterator和listIterator操作在常量时间内运行。加法运算在平摊常数时间内进行，
      也就是说，添加n个元素需要O(n)时间。所有其他操作都在线性时间内运行(粗略地说)。常数因子比较低
      对于LinkedList实现。
   */

   /*< p >每个ArrayList实例都有一个容量。容量是用于存储列表中元素的数组的大小。它总是至少和列表大小一样大。当元
     素被添加到ArrayList中时，它的容量会自动增长。除了添加一个元素具有恒定的平摊时间代价之外，没有指定增长策
    略的细节。
   */

   /*< p >在使用ensureCapacity操作添加大量元素之前，应用程序可以增加ArrayList实例的容量。这可能会减少增量重新
      分配的数量。
   */

  /*< p >注意，这个实现不是同步的。
    如果多个线程同时访问一个ArrayList实例，并且至少有一个线程从结构上修改了这个列表，那么它必须在外部同步。
    (结构修改是添加或删除一个或多个元素，或显式调整支持数组的大小的任何操作;仅仅设置元素的值并不是结构上的
    修改。)这通常是通过对一些自然封装列表的对象进行同步来实现的。
  */

  /*< p >如果不存在这样的对象，则应该使用{@link Collections.synchronizedList Collections“包装”列表。
    synchronizedList}方法。这最好在创建时完成，以防止对列表的意外非同步访问:
    List =集合。synchronizedList(new ArrayList (…));
  */

  /*< p > < name = "快速失败" >
    *该类的{@link #iterator() iterator}和返回的迭代器
    {@link #listIterator(int) listIterator}方法是fail-fast:
    如果在创建迭代器之后，以任何方式在结构上修改列表，除了通过迭代器自己的{@link ListIterator#remove()}
    或{@link ListIterator#add(Object) add}方法之外，迭代器将抛出{@link ConcurrentModificationException}。
    因此，在面对并发修改时，迭代器会快速而干净地失败，而不是在将来某个不确定的时间冒着任意的、不确定的行为的风险。
  */

  /*注意，不能保证迭代器的快速故障行为，因为一般来说，在存在非同步并发修改的情况下，不可能做出任何严格的保证。故障
    快速迭代器以最大的努力抛出{@code ConcurrentModificationException}。因此，编写一个依赖于这个异常来判断其正确性
    的程序是错误的:迭代器的快速故障行为应该只用于检测bug
  */

  /*这个类是
    < a href = {@docRoot}/../technotes/guides/collections/index.html"> Java集合框架。
  */

   * @author  Josh Bloch   Java 集合框架创办人，Joshua Bloch 领导了很多 Java 平台特性的设计和实现，包括 JDK 5.0 语言
                           增强以及屡获殊荣的 Java 集合框架。2004年6月他离开了SUN公司并成为 Google 的首席 Java 架构师。此外他还因为
                           《Effective Java》一书获得著名的 Jolt 大奖。

   * @author  Neal Gafter  import java.util.Random;                         /*Neal Gafter 曾经出的题*/
                           // Rhymes,押韵
                           public class Rhymes {
                               private static Random rnd = new Random();
                               /**
                                * 以下程序的输出有可能是什么?
                                * (a) Pain ,Gain 或者 Main (根据各个随机数)
                                * (b) Pain 或者 Main (根据随机数)
                                * (c) Main (总是这个)
                                * (d) 以上都不对       /*选D三个错
                                                            1.  显然,在 switch语句中没有 break
                                                            2. nextInt(2) 返回的结果只有 0  或者 1
                                                            3. new new StringBuffer('P')只能将char
                                                            转换为int当容量大小*/
                                */
                               public static void main(String[] args) {
                                   StringBuffer word = null;
                                   switch (rnd.nextInt(2)) {
                                   case 1: word = new StringBuffer('P');
                                   case 2: word = new StringBuffer('G');
                                   default: word = new StringBuffer('M');
                                   }
                                   word.append('a');
                                   word.append('i');
                                   word.append('n');
                                   System.out.println(word);
                               }
                           }
   * @see     Collection            在写java时,有时需要写注释,而为了更好的描述,需要引用和参考其他代码.为了让阅读者更好
   * @see     List                  的体验,javadoc中支持链接跳转,这就需要用到注解@see.
   * @see     LinkedList
   * @see     Vector
   * @since   1.2                   开始版本
   public class ArrayList<E> extends AbstractList<E>      /*为什么类要首先声明cloneable标记接口，然后重写clone()方法？
     implements List<E>, RandomAccess, Cloneable, java.io.Serializable    因为不声明cloneable调用clone()方法会抛出
   {       /*RandomAccess用来表明其支持快速（通常是固定时间）随机访问。*/    CloneNotSupportedException异常 */
        private static final long serialVersionUID = 8683452581122892189L;/*序列化的版本号*/
        /*
        默认初始容量
        */
        private static final int DEFAULT_CAPACITY = 10;
        /*
        用于共享空的实例
        */
        private static final Object[] EMPTY_ELEMENTDATA = {};
        /*
       共享空数组实例，用于默认大小的空实例。我们将其与EMPTY_ELEMENTDATA区分开来，以了解添加第一个元素时应该膨胀多少。
        */
        private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
        /*
        存储ArrayList元素的数组缓冲区。ArrayList的容量是这个数组缓冲区的长度。当添加第一个元素时，任何带有
        elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA的空ArrayList都将扩展为DEFAULT_CAPACITY。
        */
        transient Object[] elementData;/*非私有以简化嵌套类访问*/
        /*
        ArrayList的大小(它包含的元素的数量)。注释中的@serial生成序列化供参考的文档界面
        */
        private int size;
        /*
        构造具有指定初始容量的空列表。
        @param  initialCapacity 列表的初始容量
        @throws IllegalArgumentException 如果指定的初始容量为负
        */
        public ArrayList(int initialCapacity) {
                if (initialCapacity > 0) {
                    this.elementData = new Object[initialCapacity];
                } else if (initialCapacity == 0) {
                    this.elementData = EMPTY_ELEMENTDATA;
                } else {
                    throw new IllegalArgumentException("Illegal Capacity: "+
                                                       initialCapacity);
                }
        }
        /*
        构造一个初始容量为10的空列表。
        */
        public ArrayList() {
                this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
        }
        /*
        构造包含指定集合的元素的列表，按集合的迭代器返回元素的顺序排列。
        @param c 要将其元素放入此列表的集合
        @throws NullPointerException 如果指定的集合为空
        */
        public ArrayList(Collection<? extends E> c) {
                elementData = c.toArray();
                if ((size = elementData.length) != 0) {
                    // c.toArray 可能 (不正确) 不是 return Object[] (可能是泛型通过反射不是Object.class)
                    if (elementData.getClass() != Object[].class)
                        elementData = Arrays.copyOf(elementData, size, Object[].class);
                } else {
                    // 替换为 EMPTY_ELEMENTDATA.
                    this.elementData = EMPTY_ELEMENTDATA;
                }
        }
        /*
        将这个ArrayList实例的容量缩减为列表的当前大小。应用程序可以使用此操作最小化ArrayList实例的存储。
        */
        public void trimToSize() {
                modCount++;//通过这个数检测是否被更改,然后提供一个fail-fast迭代器
                if (size < elementData.length) {
                    elementData = (size == 0)
                      ? EMPTY_ELEMENTDATA
                      : Arrays.copyOf(elementData, size);
                }
        }
        /*
        增加这个ArrayList实例的容量(如果需要的话)，以确保它至少可以容纳由最小容量参数指定的元素数量。
        @param   minCapacity 所需的最小容量
        */
        public void ensureCapacity(int minCapacity) {
                int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
                 // 任何长度只要不是默认空数组,都需要重新调整
                 ? 0
                 // 如果是默认数组,那么长度就是默认大小
                 : DEFAULT_CAPACITY;

                if (minCapacity > minExpand) {
                    ensureExplicitCapacity(minCapacity);
                }
        }
        /*
        计算容量:查看数组是否是默认空数组,是的话找到默认和最小容量中大的那个,如果不是直接返回最小容量
        */
        private static int calculateCapacity(Object[] elementData, int minCapacity) {
                if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
                    return Math.max(DEFAULT_CAPACITY, minCapacity);
                }
                return minCapacity;
        }
        private void ensureCapacityInternal(int minCapacity) {
                ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
        }
        /*
        扩容:
        */
        private void ensureExplicitCapacity(int minCapacity) {
                modCount++;

                // 防止溢出代码
                if (minCapacity - elementData.length > 0)
                    grow(minCapacity);
        }
        /*
        要分配的数组的最大大小。一些vm在数组中保留一些头信息。试图分配更大的数
        组可能会导致OutOfMemoryError:请求的数组大小超过VM限制
        */
        private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
        /*
        增加容量，以确保它至少可以容纳由最小容量参数指定的元素数量。
        @param minCapacity 所需的最小容量
        */
        private void grow(int minCapacity) {
                // 会溢出的代码
                int oldCapacity = elementData.length;
                int newCapacity = oldCapacity + (oldCapacity >> 1);
                if (newCapacity - minCapacity < 0)
                    newCapacity = minCapacity;
                if (newCapacity - MAX_ARRAY_SIZE > 0)
                    newCapacity = hugeCapacity(minCapacity);
                // minCapacity 通常接近 size, so this is a win:
                elementData = Arrays.copyOf(elementData, newCapacity);
        }
        /*
        如果新容量大于提前设置的最大数组长度,则查看最小容量和最大数组长度对比,如果最小容量大则返回Integer.MAX_VALUE
        否则返回提前设置的最大数组长度
        */
        private static int hugeCapacity(int minCapacity) {
                if (minCapacity < 0) // overflow
                    throw new OutOfMemoryError();
                return (minCapacity > MAX_ARRAY_SIZE) ?
                    Integer.MAX_VALUE :
                    MAX_ARRAY_SIZE;
        }
        /*
        返回此列表中的元素数量。
        @return 列表中元素的数量
        */
        public int size() {
                return size;
        }
        /*
        如果没有元素返回true
        */
        public boolean isEmpty() {
                return size == 0;
        }
        /*
        如果存在返回true,元素可以是null
        */
        public boolean contains(Object o) {
                return indexOf(o) >= 0;
        }
        /*
        根据下标寻找,找不到返回-1,元素可以是null
        */
        public int indexOf(Object o) {
                if (o == null) {
                    for (int i = 0; i < size; i++)
                        if (elementData[i]==null)
                            return i;
                } else {
                    for (int i = 0; i < size; i++)
                        if (o.equals(elementData[i]))
                            return i;
                }
                return -1;
        }
        /*
        返回此列表中指定元素的最后一次出现的索引，如果该列表不包含该元素，则返回-1,元素可以是null
        */
        public int lastIndexOf(Object o) {
                if (o == null) {
                    for (int i = size-1; i >= 0; i--)
                        if (elementData[i]==null)
                            return i;
                } else {
                    for (int i = size-1; i >= 0; i--)
                        if (o.equals(elementData[i]))
                            return i;
                }
                return -1;
        }
        /*
        返回此ArrayList实例的浅拷贝。(元素本身不会被复制。)
        @return 这个ArrayList实例的克隆
        */
        public Object clone() {
                try {
                    ArrayList<?> v = (ArrayList<?>) super.clone();
                    v.elementData = Arrays.copyOf(elementData, size);
                    v.modCount = 0;
                    return v;
                } catch (CloneNotSupportedException e) {
                    // 这个不应该发生,因为实现了Cloneable接口
                    throw new InternalError(e);
                }
        }
        /*
        返回一个数组，该数组按适当的顺序(从第一个元素到最后一个元素)包含列表中的所有元素。
        返回的数组将是“安全的”，因为这个列表不维护对它的引用。(换句话说，这个方法必须分
        配一个新的数组)。因此，调用者可以自由地修改返回的数组。
        此方法充当基于数组和基于集合的api之间的桥梁。
         @return 一个数组，按适当的顺序包含列表中的所有元素
        */
        public Object[] toArray() {
                return Arrays.copyOf(elementData, size);
        }
        /*
        返回一个数组，该数组包含列表中按正确顺序排列的所有元素(从第一个元素到最后一个元素);
        返回数组的运行时类型是指定数组的运行时类型。如果列表符合指定的数组，则返回其中的列表。
        否则，将使用指定数组的运行时类型和该列表的大小分配一个新数组。

        如果列表符合指定的数组，并且有多余的空间(即，数组中的元素比列表中的元素多)，集合结束后
        数组中的元素被设置为null。(当调用者知道列表不包含任何空元素时，这对于确定列表 的长度非常有用。)
        @param a 如果列表的元素足够大，则将其存储到其中的数组;否则，将为此目的分配相同运行时类型的新数组。
        @return 包含列表元素的数组
        @throws ArrayStoreException 如果指定数组的运行时类型不是此列表中每个元素的运行时类型的超类型
        @throws NullPointerException 如果指定的数组为空
        */
        @SuppressWarnings("unchecked")//警告压制
        public <T> T[] toArray(T[] a) {
                if (a.length < size)
                    //为a的运行时类型，但为我的内容创建一个新数组:
                    return (T[]) Arrays.copyOf(elementData, size, a.getClass());
                System.arraycopy(elementData, 0, a, 0, size);
                if (a.length > size)
                    a[size] = null;
                return a;
        }
        //位置访问操作
        @SuppressWarnings("unchecked")
        E elementData(int index) {
                    return (E) elementData[index];
        }
        / * *
        *返回列表中指定位置的元素。
        *
        * @param索引要返回的元素的索引
        * @返回列表中指定位置的元素
        *抛出IndexOutOfBoundsException {@inheritDoc}
        */
        public E get(int index) {
           rangeCheck(index);

           return elementData(index);
        }
        / * *
        *将列表中指定位置的元素替换为
        *指定的元素。
        *
        * @param索引要替换的元素的索引
        * @param元素将存储在指定位置
        * @返回前面指定位置的元素
        *抛出IndexOutOfBoundsException {@inheritDoc}
        */
        public E set(int index, E element) {
            rangeCheck(index);

            E oldValue = elementData(index);
            elementData[index] = element;
            return oldValue;
        }
        / * *
        *将指定的元素追加到此列表的末尾。
        *
        * @param e元素添加到此列表
        * @return true(由{@link Collection#add}指定)
        */
        public boolean add(E e) {
            ensureCapacityInternal(size + 1);  // 增加 modCount!!
            elementData[size++] = e;
            return true;
        }
        / * *
        *将指定元素插入其中的指定位置
        *列表。将当前位于该位置(如果有)的元素移动，并
        *右边的任何后续元素(将一个元素添加到它们的索引中)。
        *
        * @param index 要插入指定元素的索引
        *@param element 要插入的元素
        *抛出IndexOutOfBoundsException {@inheritDoc}
        */
        public void add(int index, E element) {
            rangeCheckForAdd(index);

            ensureCapacityInternal(size + 1);  // 增加 modCount!!
            System.arraycopy(elementData, index, elementData, index + 1,
                             size - index);
            elementData[index] = element;
            size++;
        }
        / * *
        *移除列表中指定位置的元素。
        *将任何后续元素向左移动(从它们的元素中减去一个)
        *指数)。
        *
        * @param索引要删除的元素的索引
        * @返回从列表中删除的元素
        *抛出IndexOutOfBoundsException {@inheritDoc}
        */
        public E remove(int index) {
            rangeCheck(index);

            modCount++;
            E oldValue = elementData(index);

            int numMoved = size - index - 1;
            if (numMoved > 0)
                System.arraycopy(elementData, index+1, elementData, index,
                                 numMoved);
            elementData[--size] = null; // clear to let GC do its work

            return oldValue;
        }
        / * *
        *从列表中移除指定元素的第一个出现项，
        如果有的话。如果列表不包含该元素，则它包含
        *不变。更正式地说，删除索引最低的元素
        * i这样
        * < tt > (o == null  ?得到(i) == null :, o.equals (get (i))) < / tt >
        *(如果存在这样的元素)。返回true如果这个列表
        *包含指定的元素(或相等，如果此列表
        *由于调用而更改)。
        *
        * @param o元素，如果存在，将从该列表中删除
        * @return true如果这个列表包含指定的元素
        */
        public boolean remove(Object o) {
            if (o == null) {
                for (int index = 0; index < size; index++)
                    if (elementData[index] == null) {
                        fastRemove(index);
                        return true;
                                         }
            } else {
                for (int index = 0; index < size; index++)
                    if (o.equals(elementData[index])) {
                        fastRemove(index);
                        return true;
                    }
            }
            return false;
        }
        / *
        *私有删除跳过边界检查和跳过
        *返回删除的值。
        */
        private void fastRemove(int index) {
            modCount++;
            int numMoved = size - index - 1;
            if (numMoved > 0)
                System.arraycopy(elementData, index+1, elementData, index,
                                 numMoved);
            elementData[--size] = null; // 清除，让GC完成它的工作
        }
        / * *
        *从列表中删除所有元素。
        *返回后为空。
        */
        public void clear() {
            modCount++;

            // clear to let GC do its work
            for (int i = 0; i < size; i++)
                elementData[i] = null;

            size = 0;
        }
        / * *
        *将指定集合中的所有元素追加到
        *此列表，按其返回的顺序排列
        指定集合的迭代器。这个操作的行为是
        *如果在操作期间修改了指定的集合，则未定义
        *正在进行中。(这意味着这个调用的行为是
        *如果指定的集合是这个列表，则未定义
        *列表非空。)
        *
        * @param c集合，其中包含要添加到此列表中的元素
        * @return true如果这个列表由于调用而更改
        * @如果指定的集合为null，则抛出NullPointerException
        */
        public boolean addAll(Collection<? extends E> c) {
            Object[] a = c.toArray();
            int numNew = a.length;
            ensureCapacityInternal(size + numNew);  // 增加 modCount
            System.arraycopy(a, 0, elementData, size, numNew);
            size += numNew;
            return numNew != 0;
        }
        / * *
        从指定位置开始，将指定集合中的所有元素插入此列表。将当前位于该位置的元素(如果有的话)和随后的任何元素移动到右边(增加它们的索引)。新元素将按指定集合的迭代器返回它们的顺序出现在列表中。
        从指定集合中插入第一个元素的索引
        @param c 包含要添加到此列表中的元素的集合
        @return true 如果这个列表因为调用而改变
        @throws IndexOutOfBoundsException {@inheritDoc}
        如果指定的集合为空，@抛出NullPointerException
        */
        public boolean addAll(int index, Collection<? extends E> c) {
            rangeCheckForAdd(index);

            Object[] a = c.toArray();
            int numNew = a.length;
            ensureCapacityInternal(size + numNew);  // Increments modCount

            int numMoved = size - index;
            if (numMoved > 0)
                System.arraycopy(elementData, index, elementData, index + numNew,
                                 numMoved);

            System.arraycopy(a, 0, elementData, index, numNew);
            size += numNew;
            return numNew != 0;
        }
        / * *
        从该列表中删除索引位于{@code fromIndex}(包含)和{@code toIndex}(排除)之间
        的所有元素。将任何后续元素向左移动(减少它们的索引)。这个调用通过
        {@code (toIndex - fromIndex)}元素缩短列表。
        (If {@code toIndex==fromIndex},则此操作无效)

        抛出 @throws IndexOutOfBoundsException
        if {@code fromIndex} or
             *         {@code toIndex} is out of range
             *         ({@code fromIndex < 0 ||
             *          fromIndex >= size() ||
             *          toIndex > size() ||
             *          toIndex < fromIndex})
         **/
        protected void removeRange(int fromIndex, int toIndex) {
            modCount++;
            int numMoved = size - toIndex;
            System.arraycopy(elementData, toIndex, elementData, fromIndex,
                             numMoved);

            // 清除方便垃圾回收器回收
            int newSize = size - (toIndex-fromIndex);
            for (int i = newSize; i < size; i++) {
                elementData[i] = null;
            }
            size = newSize;
        }
        /*
        检查给定索引是否在范围内。如果没有，则抛出适当的运行时异常。这个方法不
        检查索引是否为负数:它总是在数组访问之前使用，如果索引为负数，
        数组访问将抛出一个ArrayIndexOutOfBoundsException
        */
        private void rangeCheck(int index) {
            if (index >= size)
                throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
        }
        /*
        add和addAll使用的范围检查的版本。
        */
        private void rangeCheckForAdd(int index) {
            if (index > size || index < 0)
                throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
        }
        / * *
        构造IndexOutOfBoundsException详细信息。在错误处理代码的许多可能重构中，
        *这个“大纲”在服务器和客户机vm上都表现得最好。
        */
        private String outOfBoundsMsg(int index) {
            return "Index: "+index+", Size: "+size;
        }
        / * *
        *从该列表中删除指定集合中包含的所有元素。
        *
        * @param c 集合，其中包含要从此列表中删除的元素
        * @return {@code true}如果这个列表因为调用而改变
        * @throw ClassCastException如果列表中元素的类与指定集合不兼容
        * (< a href = " Collection.html # optional-restrictions " >可选< / >)
        * @throw NullPointerException，如果该列表包含一个空元素而指定的集合不允许空元素
        *或指定的集合为空
        * # @see集合包含(对象)
        */
        public boolean removeAll(Collection<?> c) {
            Objects.requireNonNull(c);//判读c==null如果是抛异常
            return batchRemove(c, false);
        }
        / * *
        *只保留此列表中包含在指定集合中的元素。换句话说，从这个列表中删除指定集合中不包含的所有元素。

        * @param c集合，其中包含要保留在此列表中的元素
        * @return返回{@code true}如果这个列表因为调用而改变
        * @抛出ClassCastException，如果该类是这个列表中的一个元素与指定的集合不兼容
        * (< a href = " Collection.html # optional-restrictions " >可选< / >)
        * @抛出NullPointerException，如果该列表包含一个空元素而指定的集合不允许空元素或指定的集合为空
        * # @see集合包含(对象)
        */
        public boolean retainAll(Collection<?> c) {
            Objects.requireNonNull(c);
            return batchRemove(c, true);
        }
        /**
        *移出元素,boolean值为true则留下集合里有的,如果为false则留下集合没有的
        */
        private boolean batchRemove(Collection<?> c, boolean complement) {
            final Object[] elementData = this.elementData;
            int r = 0, w = 0;
            boolean modified = false;
            try {
                for (; r < size; r++)
                    if (c.contains(elementData[r]) == complement)
                        elementData[w++] = elementData[r];
            } finally {
                // 即使c.contains()抛出，也要保持与AbstractCollection的行为兼容性,防止中途出现异常导致r!=size
                if (r != size) {
                    System.arraycopy(elementData, r,
                                     elementData, w,
                                     size - r);
                    w += size - r;
                }
                if (w != size) {
                    // clear to let GC do its work
                    for (int i = w; i < size; i++)
                        elementData[i] = null;
                    modCount += size - w;
                    size = w;
                    modified = true;
                }
            }
            return modified;
        }
        /*
        将ArrayList实例的状态保存到流中(即序列化它)。
        @serialData返回ArrayList实例的数组的长度(int)，后面跟着它的所有元素(每个对象)，顺序正确。
        */
       private void writeObject(java.io.ObjectOutputStream s)
           throws java.io.IOException{
           // 写出元素计数和任何隐藏的东西
           int expectedModCount = modCount;
           s.defaultWriteObject();//进行序列化

           // 将大小作为与克隆行为兼容的能力()
           s.writeInt(size);

           // 按正确的顺序写出所有的元素。
           for (int i=0; i<size; i++) {
               s.writeObject(elementData[i]);
           }

           if (modCount != expectedModCount) {
               throw new ConcurrentModificationException();
           }
       }

        /*
        从流(即反序列化)中重新构造ArrayList实例。
        */
        private void readObject(java.io.ObjectInputStream s)
            throws java.io.IOException, ClassNotFoundException {
            elementData = EMPTY_ELEMENTDATA;

            // 写出元素计数和任何隐藏的东西
            s.defaultReadObject();

            // 读取容量
            s.readInt(); // 忽略

            if (size > 0) {
                // 类似clone()，根据大小而不是容量分配数组
                int capacity = calculateCapacity(elementData, size);
                SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);
                ensureCapacityInternal(size);

                Object[] a = elementData;
                //按适当的顺序读取所有元素。
                for (int i=0; i<size; i++) {
                    a[i] = s.readObject();
                }
            }
        }

        /*
        返回列表中元素的列表迭代器(按适当的顺序)，从列表中的指定位置开始。指定的索引指示初始
        调用{@link ListIterator#next}返回的第一个元素。对{@link ListIterator#previous }
        的初始调用将返回具有指定索引- 1的元素。
        返回的列表迭代器是fail-fast。
        */
        public ListIterator<E> listIterator(int index) {
            if (index < 0 || index > size)
                throw new IndexOutOfBoundsException("Index: "+index);
            return new ListItr(index);
        }
        /*
        返回列表中元素的列表迭代器(按适当的顺序)。
        */
        public ListIterator<E> listIterator() {
            return new ListItr(0);
        }
        /*
        按正确的顺序返回列表中元素的迭代器。
        */
        public Iterator<E> iterator() {
            return new Itr();
        }
        /*
        一个优化版的AbstractList.Itr
        */
        private class Itr implements Iterator<E> {
            int cursor;       // 要返回的下一个元素的索引
            int lastRet = -1; // 返回的最后一个元素的索引;-1如果没有
            int expectedModCount = modCount;

            Itr() {}

            public boolean hasNext() {
                return cursor != size;
            }

            @SuppressWarnings("unchecked")
            public E next() {
                checkForComodification();
                int i = cursor;
                if (i >= size)
                    throw new NoSuchElementException();
                Object[] elementData = ArrayList.this.elementData;
                if (i >= elementData.length)
                    throw new ConcurrentModificationException();
                cursor = i + 1;
                return (E) elementData[lastRet = i];
            }

            public void remove() {
                if (lastRet < 0)
                    throw new IllegalStateException();
                checkForComodification();

                try {
                    ArrayList.this.remove(lastRet);
                    cursor = lastRet;
                    lastRet = -1;
                    expectedModCount = modCount;
                } catch (IndexOutOfBoundsException ex) {
                    throw new ConcurrentModificationException();
                }
            }

            /*
            Consumer接口定义指定操作,直到所有元素被处理
            */
            @Override
            @SuppressWarnings("unchecked")
            public void forEachRemaining(Consumer<? super E> consumer) {
                Objects.requireNonNull(consumer);
                final int size = ArrayList.this.size;
                int i = cursor;
                if (i >= size) {
                    return;
                }
                final Object[] elementData = ArrayList.this.elementData;
                if (i >= elementData.length) {
                    throw new ConcurrentModificationException();
                }
                while (i != size && modCount == expectedModCount) {
                    consumer.accept((E) elementData[i++]);
                }
                // 在迭代结束时更新一次，以减少堆写流量
                cursor = i;
                lastRet = i - 1;
                checkForComodification();
            }

            final void checkForComodification() {
                if (modCount != expectedModCount)
                    throw new ConcurrentModificationException();
            }
        }

        /*
        一个优化版的AbstractList.ListItr
        */
        private class ListItr extends Itr implements ListIterator<E> {
            ListItr(int index) {
                super();
                cursor = index;
            }

            public boolean hasPrevious() {
                return cursor != 0;
            }

            public int nextIndex() {
                return cursor;
            }

            public int previousIndex() {
                return cursor - 1;
            }

            /*
            前一个
            */
            @SuppressWarnings("unchecked")
            public E previous() {
                checkForComodification();
                int i = cursor - 1;
                if (i < 0)
                    throw new NoSuchElementException();
                Object[] elementData = ArrayList.this.elementData;
                if (i >= elementData.length)
                    throw new ConcurrentModificationException();
                cursor = i;
                return (E) elementData[lastRet = i];
            }

            public void set(E e) {
                if (lastRet < 0)
                    throw new IllegalStateException();
                checkForComodification();

                try {
                    ArrayList.this.set(lastRet, e);
                } catch (IndexOutOfBoundsException ex) {
                    throw new ConcurrentModificationException();
                }
            }

            public void add(E e) {
                checkForComodification();

                try {
                    int i = cursor;
                    ArrayList.this.add(i, e);
                    cursor = i + 1;
                    lastRet = -1;
                    expectedModCount = modCount;
                } catch (IndexOutOfBoundsException ex) {
                    throw new ConcurrentModificationException();
                }
            }
        }
        /*
        返回列表中指定的{@code fromIndex}(包含)和{@code toIndex}(排除)之间部分的视图
        。(如果{@code fromIndex}和{@code toIndex}相等，则返回的列表为空。)返回的列表由该列表支
        持，因此返回列表中的非结构性更改将反映在该列表中，反之亦然。返回的列表支持所有可选列表操作。

        对于{@link #indexOf(Object)}和{@link #lastIndexOf(Object)}可以构造类似的习惯用法，并
        且{@link Collections}类中的所有算法都可以应用于子列表。

        这种方法不需要显式的范围操作(数组中通常存在的那种)。任何需要列表的操作都可以作为范围操作
        使用，方法是传递子列表视图而不是整个列表。例如，下面的习惯用法从列表中
        删除一系列元素: list.subList(from, to).clear();
        */
        public List<E> subList(int fromIndex, int toIndex) {
            subListRangeCheck(fromIndex, toIndex, size);
            return new SubList(this, 0, fromIndex, toIndex);
        }

        static void subListRangeCheck(int fromIndex, int toIndex, int size) {
            if (fromIndex < 0)
                throw new IndexOutOfBoundsException("fromIndex = " + fromIndex);
            if (toIndex > size)
                throw new IndexOutOfBoundsException("toIndex = " + toIndex);
            if (fromIndex > toIndex)
                throw new IllegalArgumentException("fromIndex(" + fromIndex +
                                                   ") > toIndex(" + toIndex + ")");
        }

        private class SubList extends AbstractList<E> implements RandomAccess {
            private final AbstractList<E> parent;//原来的数组表
            private final int parentOffset;//从哪个开始留下
            private final int offset;//从哪个开始找
            int size;

            SubList(AbstractList<E> parent,
                    int offset, int fromIndex, int toIndex) {
                this.parent = parent;
                this.parentOffset = fromIndex;
                this.offset = offset + fromIndex;//从哪个开始+从哪里留下
                this.size = toIndex - fromIndex;//大小
                this.modCount = ArrayList.this.modCount;
            }

            public E set(int index, E e) {
                rangeCheck(index);
                checkForComodification();
                E oldValue = ArrayList.this.elementData(offset + index);
                ArrayList.this.elementData[offset + index] = e;
                return oldValue;
            }

            public E get(int index) {
                rangeCheck(index);
                checkForComodification();
                return ArrayList.this.elementData(offset + index);
            }

            public int size() {
                checkForComodification();
                return this.size;
            }

            public void add(int index, E e) {
                rangeCheckForAdd(index);
                checkForComodification();
                parent.add(parentOffset + index, e);
                this.modCount = parent.modCount;
                this.size++;
            }

            public E remove(int index) {
                rangeCheck(index);
                checkForComodification();
                E result = parent.remove(parentOffset + index);
                this.modCount = parent.modCount;
                this.size--;
                return result;
            }

            protected void removeRange(int fromIndex, int toIndex) {
                checkForComodification();
                parent.removeRange(parentOffset + fromIndex,
                                   parentOffset + toIndex);
                this.modCount = parent.modCount;
                this.size -= toIndex - fromIndex;
            }

            public boolean addAll(Collection<? extends E> c) {
                return addAll(this.size, c);
            }

            public boolean addAll(int index, Collection<? extends E> c) {
                rangeCheckForAdd(index);
                int cSize = c.size();
                if (cSize==0)
                    return false;

                checkForComodification();
                parent.addAll(parentOffset + index, c);
                this.modCount = parent.modCount;
                this.size += cSize;
                return true;
            }

            public Iterator<E> iterator() {
                return listIterator();
            }

            public ListIterator<E> listIterator(final int index) {
                checkForComodification();
                rangeCheckForAdd(index);
                final int offset = this.offset;

                return new ListIterator<E>() {
                    int cursor = index;
                    int lastRet = -1;
                    int expectedModCount = ArrayList.this.modCount;

                    public boolean hasNext() {
                        return cursor != SubList.this.size;
                    }

                    @SuppressWarnings("unchecked")
                    public E next() {
                        checkForComodification();
                        int i = cursor;
                        if (i >= SubList.this.size)
                            throw new NoSuchElementException();
                        Object[] elementData = ArrayList.this.elementData;
                        if (offset + i >= elementData.length)
                            throw new ConcurrentModificationException();
                        cursor = i + 1;
                        return (E) elementData[offset + (lastRet = i)];
                    }

                    public boolean hasPrevious() {
                        return cursor != 0;
                    }

                    @SuppressWarnings("unchecked")
                    public E previous() {
                        checkForComodification();
                        int i = cursor - 1;
                        if (i < 0)
                            throw new NoSuchElementException();
                        Object[] elementData = ArrayList.this.elementData;
                        if (offset + i >= elementData.length)
                            throw new ConcurrentModificationException();
                        cursor = i;
                        return (E) elementData[offset + (lastRet = i)];
                    }

                    @SuppressWarnings("unchecked")
                    public void forEachRemaining(Consumer<? super E> consumer) {
                        Objects.requireNonNull(consumer);
                        final int size = SubList.this.size;
                        int i = cursor;
                        if (i >= size) {
                            return;
                        }
                        final Object[] elementData = ArrayList.this.elementData;
                        if (offset + i >= elementData.length) {
                            throw new ConcurrentModificationException();
                        }
                        while (i != size && modCount == expectedModCount) {
                            consumer.accept((E) elementData[offset + (i++)]);
                        }
                        // update once at end of iteration to reduce heap write traffic
                        lastRet = cursor = i;
                        checkForComodification();
                    }

                    public int nextIndex() {
                        return cursor;
                    }

                    public int previousIndex() {
                        return cursor - 1;
                    }

                    public void remove() {
                        if (lastRet < 0)
                            throw new IllegalStateException();
                        checkForComodification();

                        try {
                            SubList.this.remove(lastRet);
                            cursor = lastRet;
                            lastRet = -1;
                            expectedModCount = ArrayList.this.modCount;
                        } catch (IndexOutOfBoundsException ex) {
                            throw new ConcurrentModificationException();
                        }
                    }

                    public void set(E e) {
                        if (lastRet < 0)
                            throw new IllegalStateException();
                        checkForComodification();

                        try {
                            ArrayList.this.set(offset + lastRet, e);
                        } catch (IndexOutOfBoundsException ex) {
                            throw new ConcurrentModificationException();
                        }
                    }

                    public void add(E e) {
                        checkForComodification();

                        try {
                            int i = cursor;
                            SubList.this.add(i, e);
                            cursor = i + 1;
                            lastRet = -1;
                            expectedModCount = ArrayList.this.modCount;
                        } catch (IndexOutOfBoundsException ex) {
                            throw new ConcurrentModificationException();
                        }
                    }

                    final void checkForComodification() {
                        if (expectedModCount != ArrayList.this.modCount)
                            throw new ConcurrentModificationException();
                    }
                };
            }

            public List<E> subList(int fromIndex, int toIndex) {
                subListRangeCheck(fromIndex, toIndex, size);
                return new SubList(this, offset, fromIndex, toIndex);
            }

            private void rangeCheck(int index) {
                if (index < 0 || index >= this.size)
                    throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
            }

            private void rangeCheckForAdd(int index) {
                if (index < 0 || index > this.size)
                    throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
            }

            private String outOfBoundsMsg(int index) {
                return "Index: "+index+", Size: "+this.size;
            }

            private void checkForComodification() {
                if (ArrayList.this.modCount != this.modCount)
                    throw new ConcurrentModificationException();
            }

            public Spliterator<E> spliterator() {
                checkForComodification();
                return new ArrayListSpliterator<E>(ArrayList.this, offset,
                                                   offset + this.size, this.modCount);
            }
        }

        @Override
        public void forEach(Consumer<? super E> action) {
            Objects.requireNonNull(action);
            final int expectedModCount = modCount;
            @SuppressWarnings("unchecked")
            final E[] elementData = (E[]) this.elementData;
            final int size = this.size;
            for (int i=0; modCount == expectedModCount && i < size; i++) {
                action.accept(elementData[i]);
            }
            if (modCount != expectedModCount) {
                throw new ConcurrentModificationException();
            }
        }
        /*
        Spliterator（splitable iterator可分割迭代器）接口是Java为了并行遍历数据源中的
        元素而设计的迭代器，这个可以类比最早Java提供的顺序遍历迭代器Iterator，但一个是顺序遍历，一个是并行遍历
        */
        @Override
        public Spliterator<E> spliterator() {
            return new ArrayListSpliterator<>(this, 0, -1, 0);
        }

        /** 基于索引的二分法，延迟初始化的Spliterator */
        static final class ArrayListSpliterator<E> implements Spliterator<E> {

            /*
             * If ArrayLists were immutable, or structurally immutable (no
             * adds, removes, etc), we could implement their spliterators
             * with Arrays.spliterator. Instead we detect as much
             * interference during traversal as practical without
             * sacrificing much performance. We rely primarily on
             * modCounts. These are not guaranteed to detect concurrency
             * violations, and are sometimes overly conservative about
             * within-thread interference, but detect enough problems to
             * be worthwhile in practice. To carry this out, we (1) lazily
             * initialize fence and expectedModCount until the latest
             * point that we need to commit to the state we are checking
             * against; thus improving precision.  (This doesn't apply to
             * SubLists, that create spliterators with current non-lazy
             * values).  (2) We perform only a single
             * ConcurrentModificationException check at the end of forEach
             * (the most performance-sensitive method). When using forEach
             * (as opposed to iterators), we can normally only detect
             * interference after actions, not before. Further
             * CME-triggering checks apply to all other possible
             * violations of assumptions for example null or too-small
             * elementData array given its size(), that could only have
             * occurred due to interference.  This allows the inner loop
             * of forEach to run without any further checks, and
             * simplifies lambda-resolution. While this does entail a
             * number of checks, note that in the common case of
             * list.stream().forEach(a), no checks or other computation
             * occur anywhere other than inside forEach itself.  The other
             * less-often-used methods cannot take advantage of most of
             * these streamlinings.
             */

            private final ArrayList<E> list;
            private int index; // current index, modified on advance/split
            private int fence; // -1 until used; then one past last index
            private int expectedModCount; // initialized when fence set

            /** Create new spliterator covering the given  range */
            ArrayListSpliterator(ArrayList<E> list, int origin, int fence,
                                 int expectedModCount) {
                this.list = list; // OK if null unless traversed
                this.index = origin;
                this.fence = fence;
                this.expectedModCount = expectedModCount;
            }

            private int getFence() { // initialize fence to size on first use
                int hi; // (a specialized variant appears in method forEach)
                ArrayList<E> lst;
                if ((hi = fence) < 0) {
                    if ((lst = list) == null)
                        hi = fence = 0;
                    else {
                        expectedModCount = lst.modCount;
                        hi = fence = lst.size;
                    }
                }
                return hi;
            }

            public ArrayListSpliterator<E> trySplit() {
                int hi = getFence(), lo = index, mid = (lo + hi) >>> 1;
                return (lo >= mid) ? null : // divide range in half unless too small
                    new ArrayListSpliterator<E>(list, lo, index = mid,
                                                expectedModCount);
            }

            public boolean tryAdvance(Consumer<? super E> action) {
                if (action == null)
                    throw new NullPointerException();
                int hi = getFence(), i = index;
                if (i < hi) {
                    index = i + 1;
                    @SuppressWarnings("unchecked") E e = (E)list.elementData[i];
                    action.accept(e);
                    if (list.modCount != expectedModCount)
                        throw new ConcurrentModificationException();
                    return true;
                }
                return false;
            }

            public void forEachRemaining(Consumer<? super E> action) {
                int i, hi, mc; // hoist accesses and checks from loop
                ArrayList<E> lst; Object[] a;
                if (action == null)
                    throw new NullPointerException();
                if ((lst = list) != null && (a = lst.elementData) != null) {
                    if ((hi = fence) < 0) {
                        mc = lst.modCount;
                        hi = lst.size;
                    }
                    else
                        mc = expectedModCount;
                    if ((i = index) >= 0 && (index = hi) <= a.length) {
                        for (; i < hi; ++i) {
                            @SuppressWarnings("unchecked") E e = (E) a[i];
                            action.accept(e);
                        }
                        if (lst.modCount == mc)
                            return;
                    }
                }
                throw new ConcurrentModificationException();
            }

            public long estimateSize() {
                return (long) (getFence() - index);
            }

            public int characteristics() {
                return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;
            }
        }
   }

