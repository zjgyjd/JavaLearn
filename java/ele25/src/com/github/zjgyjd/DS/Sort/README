排序:
        选择排序  (减治思想) 即问题规模减一,剩余用同样方式治理   每次选一个最大的数交换到最后

            以下两者区别为怎么选最大的数
            直接选择排序  :

            堆排序        :

 七大排序:
        插入排序(减治算法)
               开始都是无序的,经过处理后,选出有序部分然后从无序部分抓取出来放在有序的位置
               1.在有序部分查找合适位置
                1.遍历查找(****)
                    1.从后往前 | 从前往后(其中通常为从后往前更快)

                2.二分查找(*)
        希尔排序(shell)
                预排序: 很快让数据有序   (分组插排)
                插排速度快

        快速排序:
                1.选择一个基准值(选择区间中最右边数作为基准值)
                2.遍历整个区间,每个数和基准作比较,并发生交换遍历结束后,
                使比基准值小(包括等于)在左边
                使比基准值大(包括等于)在右边
                3.快排是一种分治算法(分别对左右两边进行同样方式处理)
                直到小区间的size == 0或者 size == 1说明小区间有序

                进行分段,小的在左,大的在右
                     * 两个下标一头一尾开始走
                     * 注意基准值在右边就要从左先走,不然就会出现没有比较过的数
                     * <p>
                     * 时间复杂苏: 快速排序  O(log n * n) [最好]  O(n)[最坏]
                     * 空间复杂度            O(log n)            O(n)
                     * 选边上作为基准值时,如果数组有序或者逆序都是最坏情况

                选择基准值其他方法
                      1.随机法       random.nextInt();
                      2.三数取中法   取三个数然后取中
                      这样取出数后,在将这个值交换到右边

        归并排序:(分治算法)
                 1.把要排序区间平均切分成两部分
                 2.分治算法对左右两个小区间进行同样方式的排序
                 直到
                        size ==1 已经有序
                        size == 0 没有数了
                 3.合并两个区间

 从功能角度来分类
            直接插入排序     (减治算法)   插扑克牌  [二分查找插入排序]

            希尔排序   (插入排序进化版本)   分组插排
                分组个数从大到小,直到等于1最终插入排序

            选择排序    (减治算法)        封神榜(走一趟 ,记录一个位置)

            堆排序      (减治算法)        利用二叉堆选择最大的数

            冒泡排序    (减治算法)         狗熊搬玉米(每一次只要最大的,搬到最后)

            快速排序    (分治算法)        基准值,小的在左,大的在右(三种写基准点分左右方法)
                                                                 hover   挖坑   前后下标

            归并排序    (分治算法)         直接且两半,切到最小排序,最后两边都有序然后组合

 从时间复杂度(平均)                 (最好)已经有序
            O(n^2)                 O(n) 插入  冒泡
                插入
                选择                (空间)不是O(1)
                冒泡                快速    二叉树高度
            O(n*log n )             归并    O(n)
                 堆
                 快速               稳定的排序
                 归并                插入
            O(n^1.2)                 冒泡
                希尔排序             归并

                从数据敏感的交的(不敏感)
                 选择  归并  堆

  归并排序(非递归版)
            由于归并一开始就是两个数归并,所以可以直接从两个一组进行归并,之后也两两一归并

            需要一个循环log n 次的循环
            for(int i  = 1 ; i < length; i = i * 2){
              for(int j = 0; j < array.length; j += 2 * i){

              }
            }

