1.复杂度
    衡量算法好坏的标准,不求甚解

    时间复杂度           重点 大O渐进表示法 1.只要最高次  2.最高次项的系数为 1

    O(1)        array取下标
    O(log(n))   二分查找,和二叉树有关的
    O(n)        遍历,二叉树遍历,顺序表的头插/尾删
    O(n * log(n)) 堆排序,快速排序,归并排序
    O(n^2)      冒泡排序,插排,选择排序

    空间复杂度
    排序          快排          O(log(n)) - O(n)           保存区间两端
                  归并          O(n)                       需要零时数组去做转换

    数据结构
    1. 线性
        1. 顺序表  java.util.List<E>
        2. 链表    java.util.List<E>
        集合库
                 java.util.ArrayList<E>顺序表  优点:随机访问 RandomAccess ,implements RandomAccess

                 java.util.LinkedList<E> 链表  优点:头插/尾插时间复杂度为O(1) ,implements Deque(双向队列)

        3.栈 和 队列
        FILO                    FIFO
     栈:   java.util.Stack<E>      类
     队列: java.util.Queue<E>      接口
           java.util.LinkedList<E> 类

    2.树形结构(二叉树)
        1.链式结构      结点
            1.遍历方式
               前序|中序|后序    (递归 | 非递归)       (栈的影子 |
               层序遍历                                        队列的支持)
            2.递归的写法和理解
                1.归纳法的方式去理解: 不要一开始就进行递归展开
                    1.找到递推公式        2. 找到终止条件

                   //变化的只有参数
                   //递推: 利用现有参数, 推导出下一次调用的参数
                   //终止: 当参数满足一定条件时,停下
                   如汉诺塔(SomeTalked)
    3.堆(基本作用   找最值)
        1.逻辑上完全二叉树      2.物理数组

         操作:
        1.向下调整的操作
            前提: 只有一个位置可能不符合,其他符合

            给定要调整的树下标:
            1.判断是不是叶子,是叶子不需要调整(通过看有没有左孩子)
            2.不是叶子,一定有左孩子,不一定有右孩子(找最大孩子)
            3.比较最大孩子和根,根大则不动,否则先交换然后继续递归向下调整
        时间复杂度:O(long(n))
        2.建堆
            如果除根的位置以外,左右子树已经是堆了,就可以直接向下调整了
            所以可以从最后一个结点的双亲开始向下调整
        3.向上调整  从下往上,交换并对原位置进行向下调整

    4.排序
        七大排序
            1.插排/希尔/选择/堆排/冒泡/快排/归并
                时间复杂度                   空间复杂度           稳定性
                最好     最坏
        插排     O(n)     O(n^2)              O(1)                稳
        希尔                    分组插排                          稳定
        选择        O(n^2)                    O(1)                不稳
        堆排(大堆)O(n * log(n)                O(1)                不稳
        冒泡    O(n)      O(n^2)              O(1)                稳定
        快排 O(n*log(n))  O(n^2)         O(log(n))--O(n)          不稳
        归并        O(n*log(n))               O(n)                稳定

        什么情况进行外部排序
        1.内存放不下了
        2.先把数据切割成内存放得下的大小,一共n分
        3.把每一块排序
        4.合并n个有序数组的过程(归并)

        插排的用处:
            当数组接近有序,大概率有序
            数组的数量比较小的时候(经验值是20)